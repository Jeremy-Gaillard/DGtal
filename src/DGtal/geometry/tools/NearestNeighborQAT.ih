/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file NearestNeighborQAT.ih
 * @author Jérémy Gaillard (\c jeremy.gaillard@insa-lyon.fr )
 * Institut National des Sciences Appliquées - INSA, France
 *
 * @date 2012/07/10
 *
 * @brief Implementation of inline methods defined in NearestNeighborQAT.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <math.h>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////
#include "DGtal/geometry/tools/NearestNeighborQAT.h"
///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template<typename TImageContainer>
DGtal::NearestNeighborQAT<TImageContainer>::
NearestNeighborQAT( const Matrix & M, const Value & omega, const Vector & V, const Value & defaultValue, const TImageContainer & image )
: myM(M), myOmega(omega), myV(V), myDefaultValue(defaultValue)
{
  inverse();
  myImage = ImagePointer(new ImageContainer(image));
  myDomain = getImageBound( image.domain() );
  //myImage = ImagePointer( new ImageContainer(image) );
  Point lowerBound = myDomain.lowerBound();
  // Antecedent point, initialized as the antecedent point of the lower bound
  FirstPp = myMInv * lowerBound + myVInv;
  // Incrementation in each dimension for each step performed
  for( Dimension d = 0; d != dimension; d++ )
  {
    Point vect = Point::zero;
    vect[d] = 1;
    incr.push_back(myMInv * vect);
  }
}

template<typename TImageContainer>
typename DGtal::NearestNeighborQAT<TImageContainer>::Value
DGtal::NearestNeighborQAT<TImageContainer>::operator()( const Point & aPoint ) const
{
  Point Pp = FirstPp;
  // translates the preceding point to the correct position
  for( Dimension d = 0; d != dimension; d++ )
  {
    Pp += incr[d] * (aPoint[d] - myDomain.lowerBound()[d]);
  }
  return backwardColorNN( Pp, *myImage );
}

/*template<typename TImageContainer>
void
DGtal::NearestNeighborQAT<TImageContainer>::setImage( const ImageContainer & image )
{
  myDomain = getImageBound( image.domain() );
  myImage = ImagePointer(new ImageContainer(image));
  
  Point lowerBound = myDomain.lowerBound();
  // Antecedent point, initialized as the antecedent point of the lower bound
  FirstPp = myMInv * lowerBound + myVInv;
  // Incrementation in each dimension for each step performed
  incr.clear();
  for( Dimension d = 0; d != dimension; d++ )
  {
    Point vect = Point::zero;
    vect[d] = 1;
    incr.push_back(myMInv * vect);
  }
}*/

template<typename TImageContainer>
typename DGtal::NearestNeighborQAT<TImageContainer>::Value
DGtal::NearestNeighborQAT<TImageContainer>::
backwardColorNN( const Point & Pp, const ImageContainer & image ) const
{
  typename Point::Coordinate rx [dimension];
  
  for( Dimension d = 0; d < dimension; d++ )
  {
    // the real coordinates of the point
    double x = (double) Pp[d] / myOmegaInv;
    typename Point::Coordinate roundedX = rint( x );
    if( roundedX < image.domain().lowerBound()[d] || 
     roundedX > image.domain().upperBound()[d] )
      return myDefaultValue;
    rx[d] = roundedX;
  }
  
  return image( Point(rx) );
}

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Hidden services ------------------------------

template<typename TImageContainer>
const
typename DGtal::NearestNeighborQAT<TImageContainer>::Point
DGtal::NearestNeighborQAT<TImageContainer>::calculate ( const Point & p ) const
{
  Point returnValue = myM * p + myV;
  for( Dimension d = 0; d != dimension; d++ )
  {
    returnValue[d] /= myOmega;
  }
  return returnValue;
}

template<typename TImageContainer>
void
DGtal::NearestNeighborQAT<TImageContainer>::inverse()
{
  myOmegaInv = myM.determinant();
  assert( myOmegaInv != 0 && "M must be inversible");
  myMInv = ((myM.cofactor()).transpose() * myOmega);
  myVInv = (myM.cofactor()).transpose() * myV * -1;
}

template<typename TImageContainer>
typename DGtal::NearestNeighborQAT<TImageContainer>::Domain
DGtal::NearestNeighborQAT<TImageContainer>::getImageBound ( const Domain domain ) const
{
  Point newLower;
  Point newUpper;
  
  Point lowerBound = domain.lowerBound();
  Point upperBound = domain.upperBound();
  std::vector<Point> vertices;
  getAllVertices(vertices, 0, lowerBound, upperBound);
  typename std::vector<Point>::const_iterator it = vertices.begin();
  typename std::vector<Point>::const_iterator ite = vertices.end();
  newLower = newUpper = calculate(*it);
  it++;
  for( ; it != ite; it++ )
  {
    Point transformedPoint = calculate(*it);
    for( Dimension d = 0; d < dimension; d++ )
    {
      newLower[d] = std::min( transformedPoint[d], newLower[d] );
      newUpper[d] = std::max( transformedPoint[d], newUpper[d] );
    }
  }
  cout << newLower << " " << newUpper << endl;
  return Domain(newLower, newUpper);
}

template<typename TImageContainer>
void
DGtal::NearestNeighborQAT<TImageContainer>::
getAllVertices( std::vector<Point> & vertices, const Dimension & start, 
		const Point & startPoint, const Point & endPoint ) const
{
  vertices.push_back(startPoint);
  for( Dimension d = start; d != dimension; d++ )
  {
    Point nextPoint = startPoint;
    nextPoint[d] = endPoint[d];
    getAllVertices(vertices, d+1, nextPoint, endPoint);
  }
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


