/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file NaiveQAT.ih
 * @author Jérémy Gaillard (\c jeremy.gaillard@insa-lyon.fr )
 * Institut National des Sciences Appliquées - INSA, France
 *
 * @date 2012/07/10
 *
 * @brief Implementation of inline methods defined in NaiveQAT.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////
#include "DGtal/geometry/tools/NaiveQAT.h"
///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template<typename TImageContainer>
DGtal::NaiveQAT<TImageContainer>::NaiveQAT(const Matrix & M, const Value & omega, const Vector & V)
{
  myM = M;
  myOmega = omega;
  myV = V;
  inverse();
}

template<typename TImageContainer>
DGtal::NaiveQAT<TImageContainer>::~NaiveQAT()
{
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::transformImage( const ImageContainer & image )
{
  Domain transformedDomain = getImageBound( image.domain() );
  myImage = ImagePointer(new TImageContainer(transformedDomain));
  
  Point lowerBound = transformedDomain.lowerBound();
  Point upperBound = transformedDomain.upperBound();
  // Antecedent point, initialized as the antecedent point of the lower bound
  Point Pp = myMInv * lowerBound + myVInv;
  // Incrementation in each dimension for each step performed
  std::vector<Point> incr;
  for( Dimension d = 0; d != dimension; d++ )
  {
    Point vect = Point::zero;
    vect[d] = 1;
    if( d != dimension - 1 )
      vect[d+1] = - upperBound[d];
    incr.push_back(myMInv * vect);
  }
  std::vector<typename Point::Coordinate> components;
  
  recursiveTransform( lowerBound, upperBound, (Dimension) 0, components, 
		      incr, Pp, image );
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Hidden services ------------------------------


template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::
recursiveTransform( const Point & lowerBound, const Point & upperBound,
  Dimension dim, std::vector<typename Point::Coordinate> & components,
  const std::vector<Point> & incr, Point & Pp, const ImageContainer & image )
{
  if( dim == dimension )
  {
    typename Point::Coordinate comp [dim];
    for( Dimension i = 0; i != dim; i++ )
    {
      comp[i] = components[i];
    }
    Point p(comp);
    myImage->setValue(p, backwardColorLinear( Pp, image ));
  }
  else
  {
    for( typename Point::Coordinate c = lowerBound[dim]; c != upperBound[dim]; c++ )
    {
      std::vector<typename Point::Coordinate> localComponents = components;
      localComponents.push_back(c);
      recursiveTransform( lowerBound, upperBound, dim+1, localComponents, incr, Pp, image );
      Pp += incr[dim];
    }
    // Processing of the last component : no incrementation of Pp must be done (incrementing in another dimension)
    std::vector<typename Point::Coordinate> localComponents = components;
    localComponents.push_back(upperBound[dim]);
    recursiveTransform( lowerBound, upperBound, dim+1, localComponents, incr, Pp, image );
  }
}

template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Value
DGtal::NaiveQAT<TImageContainer>::
backwardColorLinear( const Point & Pp, const ImageContainer & image )
{
  // the real coordinates of the point
  std::vector<double> x;
  // the coefficients applied to the ceiling
  std::vector<double> r;
  // the coefficients applied to the floor
  std::vector<double> l;
  
  double val = 0;
  
  for( Dimension d = 0; d < dimension; d++ )
  {
    x.push_back( (double) Pp[d] / myOmegaInv );
    r.push_back( x[d] - floor (x[d]) );
    l.push_back( 1 - r[d] );
  }
  
  double div = 0;
  recursiveColor(val, div, x, r, l, image, 0, 0, Point::zero);
  if( div )
  {
    val /= div;
  }
  return (Value) val; // beurk
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::recursiveColor( double & val, double & div, const std::vector<double> & x,
			 const std::vector<double> & r, const std::vector<double> & l,
			 const ImageContainer & image, int dim, double localDiv, Point localPoint/*const std::vector<bool> & sequence*/) const
{
  if( dim != dimension )
  {
    {
      typename Point::Coordinate low = image.domain().lowerBound()[dim];
      typename Point::Coordinate up = image.domain().upperBound()[dim];
      // Checks if the real coordinate point's floor or ceiling is inside the image
      if( low <= floor(x[dim]) && floor(x[dim]) <= up )
      {
	Point newPoint = localPoint;
	newPoint[dim] = floor(x[dim]);
	// Recursive call on next dimension, with updated local variables
	recursiveColor( val, div, x, r, l, image, dim + 1, localDiv + l[dim], newPoint );
      }
      if( low <= ceil(x[dim]) && ceil(x[dim]) <= up )
      {
	Point newPoint = localPoint;
	newPoint[dim] = ceil(x[dim]);
	// Recursive call on next dimension, with updated local variables
	recursiveColor( val, div, x, r, l, image, dim + 1, localDiv + r[dim], newPoint );
      }
    }
  }
  else
  {
    val += image(localPoint) * localDiv;
    div += localDiv;
  }
}



template<typename TImageContainer>
const
typename DGtal::NaiveQAT<TImageContainer>::Point
DGtal::NaiveQAT<TImageContainer>::calculate ( const Point & p ) const
{
  Point returnValue = myM * p + myV;
  for( Dimension d = 0; d != dimension; d++ )
  {
    returnValue[d] /= myOmega;
  }
  return returnValue;
}

template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Domain
DGtal::NaiveQAT<TImageContainer>::getImageBound ( const Domain domain )
{
  Point newLower;
  Point newUpper;
  
  Point lowerBound = domain.lowerBound();
  Point upperBound = domain.upperBound();
  std::vector<Point> vertices;
  getAllVertices(vertices, 0, lowerBound, upperBound);
  typename std::vector<Point>::const_iterator it = vertices.begin();
  typename std::vector<Point>::const_iterator ite = vertices.end();
  newLower = newUpper = calculate(*it);
  it++;
  for( ; it != ite; it++ )
  {
    Point transformedPoint = calculate(*it);
    for( Dimension d = 0; d < dimension; d++ )
    {
      newLower[d] = std::min( transformedPoint[d], newLower[d] );
      newUpper[d] = std::max( transformedPoint[d], newUpper[d] );
    }
  }
  return Domain(newLower, newUpper);
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::
getAllVertices( std::vector<Point> & vertices, const Dimension & start, 
		const Point & startPoint, const Point & endPoint ) const
{
  vertices.push_back(startPoint);
  for( Dimension d = start; d != dimension; d++ )
  {
    Point nextPoint = startPoint;
    nextPoint[d] = endPoint[d];
    getAllVertices(vertices, d+1, nextPoint, endPoint);
  }
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::inverse()
{
  myOmegaInv = myM.determinant();
  assert( myOmegaInv != 0 && "M must be inversible");
  myMInv = ((myM.cofactor()).transpose() * myOmega);
  myVInv = (myM.cofactor()).transpose() * myV * -1;
}



//                                                                           //
///////////////////////////////////////////////////////////////////////////////


