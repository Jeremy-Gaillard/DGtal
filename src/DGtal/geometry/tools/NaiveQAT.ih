/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file NaiveQAT.ih
 * @author Jérémy Gaillard (\c jeremy.gaillard@insa-lyon.fr )
 * Institut National des Sciences Appliquées - INSA, France
 *
 * @date 2012/07/10
 *
 * @brief Implementation of inline methods defined in NaiveQAT.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////
#include "DGtal/geometry/tools/NaiveQAT.h"
///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template<typename TImageContainer>
DGtal::NaiveQAT<TImageContainer>::NaiveQAT( const Matrix & M, const Value & omega, const Vector & V, const Value & defaultValue, const ImageContainer & image )
: myM(M), myOmega(omega), myV(V), myDefaultValue(defaultValue)
{
  inverse();
  myImage = ImagePointer(new ImageContainer(image));
  myDomain = getImageBound( image.domain() );
  
  Point lowerBound = myDomain.lowerBound();
  // Antecedent point, initialized as the antecedent point of the lower bound
  FirstPp = myMInv * lowerBound + myVInv;
  // Incrementation in each dimension for each step performed
  for( Dimension d = 0; d != dimension; d++ )
  {
    Point vect = Point::zero;
    vect[d] = 1;
    incr.push_back(myMInv * vect);
  }
}

template<typename TImageContainer>
DGtal::NaiveQAT<TImageContainer>::~NaiveQAT()
{
}

/*template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::setImage( const ImageContainer & image )
{
  myDomain = getImageBound( image.domain() );
  myImage = ImagePointer(new ImageContainer(image));
  
  Point lowerBound = myDomain.lowerBound();
  // Antecedent point, initialized as the antecedent point of the lower bound
  FirstPp = myMInv * lowerBound + myVInv;
  // Incrementation in each dimension for each step performed
  incr.clear();
  for( Dimension d = 0; d != dimension; d++ )
  {
    Point vect = Point::zero;
    vect[d] = 1;
    incr.push_back(myMInv * vect);
  }
}*/

template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Value
DGtal::NaiveQAT<TImageContainer>::operator()( const Point & aPoint ) const
{
  Point Pp = FirstPp;
  // translates the preceding point to the correct position
  for( Dimension d = 0; d != dimension; d++ )
  {
    Pp += incr[d] * (aPoint[d] - myDomain.lowerBound()[d]);
  }
  return backwardColorLinear( Pp, *myImage );
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Hidden services ------------------------------


template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Value
DGtal::NaiveQAT<TImageContainer>::
backwardColorLinear( const Point & Pp, const ImageContainer & image ) const
{
  // the real coordinates of the point
  std::vector<double> x;
  // the coefficients applied to the ceiling
  std::vector<double> r;
  // the coefficients applied to the floor
  std::vector<double> l;
  
  double val = 0;
  
  for( Dimension d = 0; d < dimension; d++ )
  {
    x.push_back( (double) Pp[d] / myOmegaInv );
    r.push_back( x[d] - floor (x[d]) );
    l.push_back( 1 - r[d] );
    if( rint( x[d] ) < image.domain().lowerBound()[d] || 
     rint( x[d] ) > image.domain().upperBound()[d] )
      return myDefaultValue;
  }
  
  double div = 0;
  recursiveColor(val, div, x, r, l, image, 0, 0, Point::zero);
  if( div )
  {
    val /= div;
  }
  return (Value) val; // beurk
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::recursiveColor( double & val, double & div, const std::vector<double> & x,
			 const std::vector<double> & r, const std::vector<double> & l,
			 const ImageContainer & image, int dim, double localDiv, Point localPoint/*const std::vector<bool> & sequence*/) const
{
  if( dim != dimension )
  {
    {
      typename Point::Coordinate low = image.domain().lowerBound()[dim];
      typename Point::Coordinate up = image.domain().upperBound()[dim];
      // Checks if the real coordinate point's floor or ceiling is inside the image
      if( low <= floor(x[dim]) && floor(x[dim]) <= up )
      {
	Point newPoint = localPoint;
	newPoint[dim] = floor(x[dim]);
	// Recursive call on next dimension, with updated local variables
	recursiveColor( val, div, x, r, l, image, dim + 1, localDiv + l[dim], newPoint );
      }
      if( low <= ceil(x[dim]) && ceil(x[dim]) <= up )
      {
	Point newPoint = localPoint;
	newPoint[dim] = ceil(x[dim]);
	// Recursive call on next dimension, with updated local variables
	recursiveColor( val, div, x, r, l, image, dim + 1, localDiv + r[dim], newPoint );
      }
    }
  }
  else
  {
    val += image(localPoint) * localDiv;
    div += localDiv;
  }
}



template<typename TImageContainer>
const
typename DGtal::NaiveQAT<TImageContainer>::Point
DGtal::NaiveQAT<TImageContainer>::calculate ( const Point & p ) const
{
  Point returnValue = myM * p + myV;
  for( Dimension d = 0; d != dimension; d++ )
  {
    returnValue[d] /= myOmega;
  }
  return returnValue;
}

template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Domain
DGtal::NaiveQAT<TImageContainer>::getImageBound ( const Domain domain ) const
{
  Point newLower;
  Point newUpper;
  
  Point lowerBound = domain.lowerBound();
  Point upperBound = domain.upperBound();
  std::vector<Point> vertices;
  getAllVertices(vertices, 0, lowerBound, upperBound);
  typename std::vector<Point>::const_iterator it = vertices.begin();
  typename std::vector<Point>::const_iterator ite = vertices.end();
  newLower = newUpper = calculate(*it);
  it++;
  for( ; it != ite; it++ )
  {
    Point transformedPoint = calculate(*it);
    for( Dimension d = 0; d < dimension; d++ )
    {
      newLower[d] = std::min( transformedPoint[d], newLower[d] );
      newUpper[d] = std::max( transformedPoint[d], newUpper[d] );
    }
  }
  return Domain(newLower, newUpper);
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::
getAllVertices( std::vector<Point> & vertices, const Dimension & start, 
		const Point & startPoint, const Point & endPoint ) const
{
  vertices.push_back(startPoint);
  for( Dimension d = start; d != dimension; d++ )
  {
    Point nextPoint = startPoint;
    nextPoint[d] = endPoint[d];
    getAllVertices(vertices, d+1, nextPoint, endPoint);
  }
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::inverse()
{
  myOmegaInv = myM.determinant();
  assert( myOmegaInv != 0 && "M must be inversible");
  myMInv = ((myM.cofactor()).transpose() * myOmega);
  myVInv = (myM.cofactor()).transpose() * myV * -1;
}



//                                                                           //
///////////////////////////////////////////////////////////////////////////////


