/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file NaiveQAT.ih
 * @author Jérémy Gaillard (\c jeremy.gaillard@insa-lyon.fr )
 * Institut National des Sciences Appliquées - INSA, France
 *
 * @date 2012/07/10
 *
 * @brief Implementation of inline methods defined in NaiveQAT.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////
#include "DGtal/geometry/tools/NaiveQAT.h"
///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template<typename TImageContainer>
DGtal::NaiveQAT<TImageContainer>::NaiveQAT(const Matrix & M, const Value & omega, const Vector & V)
{
  myM = M;
  myOmega = omega;
  myV = V;
  inverse();
  // TODO : throw exception if det = 0
  // myInverseM = (myM.cofactor()).transpose() * ( myOmega / myM.determinant() );
}

template<typename TImageContainer>
DGtal::NaiveQAT<TImageContainer>::~NaiveQAT()
{
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::transformImage( const ImageContainer & image )
{
  Domain transformedDomain = getImageBound( image.domain() );
  myImage = ImagePointer(new TImageContainer(transformedDomain));
  //typename ImageContainer::Range::Iterator re = myImage->range().end();
  //for( typename ImageContainer::Range::Iterator r = myImage->range().begin(); r != re; r++)
  //  *r = 0;
  
  Point lowerBound = transformedDomain.lowerBound();
  Point upperBound = transformedDomain.upperBound();
  Point Pp = myMInv * lowerBound + myVInv;
  std::vector<Point> incr;
  for( Dimension d = 0; d != dimension; d++ )
  {
    Point vect = Point::zero;
    vect[d] = 1;
    if( d != dimension - 1 )
      vect[d+1] = - upperBound[d]; // uncertain
    incr.push_back(myMInv * vect);
  }
  std::vector<typename Point::Component> components;
  
  recursiveTransform( lowerBound, upperBound, (Dimension) 0, components, 
		      incr, Pp, image );
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::
recursiveTransform( const Point & lowerBound, const Point & upperBound,
  Dimension dim, std::vector<typename Point::Component> & components,
  const std::vector<Point> & incr, Point & Pp, const ImageContainer & image )
{
  if( dim == dimension )
  {
    typename Point::Component comp [dim];
    for( Dimension i = 0; i != dim; i++ )
    {
      comp[i] = components[i];
    }
    Point p(comp);
    myImage->setValue(p, backwardColorLinear( Pp, image ));
  }
  else
  {
    for( typename Point::Component c = lowerBound[dim]; c != upperBound[dim]; c++ )
    {
      std::vector<typename Point::Component> localComponents = components;
      localComponents.push_back(c);
      recursiveTransform( lowerBound, upperBound, dim+1, localComponents, incr, Pp, image );
      Pp += incr[dim];
    }
    // Processing of the last component : no incrementation of Pp must be done (incrementing in another dimension)
    std::vector<typename Point::Component> localComponents = components;
    localComponents.push_back(upperBound[dim]);
    recursiveTransform( lowerBound, upperBound, dim+1, localComponents, incr, Pp, image );
  }
}

template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Value
DGtal::NaiveQAT<TImageContainer>::
backwardColorLinear( const Point & Pp, const ImageContainer & image )
{
  std::vector<double> x;
  std::vector<double> r;
  std::vector<double> l;
  
  double val = 0;
  
  for( Dimension d = 0; d < dimension; d++ )
  {
    x.push_back( (double) Pp[d] / myOmegaInv );
    r.push_back( x[d] - floor (x[d]) );
    l.push_back( 1 - r[d] );
  }
  
  double div = 0;
  recursiveColor(val, div, x, r, l, image, 0, std::vector<bool>());
  if( div )
  {
    val /= div;
  }
  return (Value) val; // beurk
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::recursiveColor( double & val, double & div, const std::vector<double> & x,
			 const std::vector<double> & r, const std::vector<double> & l,
			 const ImageContainer & image, int start, const std::vector<bool> & sequence ) const
{
  if( start != dimension )
  {
    //std::vector<double>::const_iterator ite = x.end();
    //for( std::vector<double>::const_iterator it = x.begin() + start; it != ite; it++ )
    {
      typename Point::Component low = image.domain().lowerBound()[start];
      typename Point::Component up = image.domain().upperBound()[start];
      //start++;
      if( low <= floor(x[start]) && floor(x[start]) <= up )
      {
	std::vector<bool> newSequence = sequence;
	newSequence.push_back(true);
	recursiveColor( val, div, x, r, l, image, start + 1, newSequence );
      }
      if( low <= ceil(x[start]) && ceil(x[start]) <= up )
      {
	std::vector<bool> newSequence = sequence;
	newSequence.push_back(false);
	recursiveColor( val, div, x, r, l, image, start + 1, newSequence );
      }
      start++;
    }
  }
  else
  {
    double localDiv = 1;
    for( Dimension d = 0; d != dimension; d++ )
    {
      localDiv *= sequence[d] ? l[d] : r[d];
    }
    Point localPoint = Point::zero;
    for( Dimension d = 0; d != dimension; d++ )
    {
      localPoint[d] = sequence[d] ? floor(x[d]) : ceil(x[d]);
    }
    val += image(localPoint) * localDiv;
    div += localDiv;
  }
}



template<typename TImageContainer>
const
typename DGtal::NaiveQAT<TImageContainer>::Point
DGtal::NaiveQAT<TImageContainer>::calculate ( const Point & p ) const
{
  Point returnValue = myM * p + myV;
  for( Dimension d = 0; d != dimension; d++ )
  {
    returnValue[d] /= myOmega;
  }
  return returnValue;
  //return ( myM * p + myV ) / myOmega;
}

template<typename TImageContainer>
typename DGtal::NaiveQAT<TImageContainer>::Domain
DGtal::NaiveQAT<TImageContainer>::getImageBound ( const Domain domain )
{
  Point newLower;
  Point newUpper;
  
  Point lowerBound = domain.lowerBound();
  Point upperBound = domain.upperBound();
  std::vector<Point> vertices;
  getAllVertices(vertices, 0, lowerBound, upperBound);
  typename std::vector<Point>::const_iterator it = vertices.begin();
  typename std::vector<Point>::const_iterator ite = vertices.end();
  newLower = newUpper = calculate(*it);
  it++;
  for( ; it != ite; it++ )
  {
    Point transformedPoint = calculate(*it);
    for( Dimension d = 0; d < dimension; d++ )
    {
      newLower[d] = std::min( transformedPoint[d], newLower[d] );
      newUpper[d] = std::max( transformedPoint[d], newUpper[d] );
    }
  }
  return Domain(newLower, newUpper);
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::
getAllVertices( std::vector<Point> & vertices, const Dimension & start, 
		const Point & startPoint, const Point & endPoint ) const
{
  vertices.push_back(startPoint);
  for( Dimension d = start; d != dimension; d++ )
  {
    Point nextPoint = startPoint;
    nextPoint[d] = endPoint[d];
    getAllVertices(vertices, d+1, nextPoint, endPoint);
  }
}

template<typename TImageContainer>
void
DGtal::NaiveQAT<TImageContainer>::inverse()
{
  Value det = myM.determinant();
  myMInv = ((myM.cofactor()).transpose() * myOmega);
  myVInv = (myM.cofactor()).transpose() * myV * -1;
  myOmegaInv = det;
}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :





//                                                                           //
///////////////////////////////////////////////////////////////////////////////


